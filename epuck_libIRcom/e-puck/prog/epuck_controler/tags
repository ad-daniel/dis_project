!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ABS	epuck.c	88;"	d	file:
AXLE_LENGTH	epuck.c	46;"	d	file:
BETA_MIGRATION	epuck.c	91;"	d	file:
BRAITENBERG_LOWER_THRESH	epuck.c	60;"	d	file:
BRAITENBERG_SPEED_BIAS	epuck.c	61;"	d	file:
BRAITENBERG_UPPER_THRESH	epuck.c	59;"	d	file:
FLOCK_SIZE	epuck.c	43;"	d	file:
JOIN_BIAS	epuck.c	66;"	d	file:
JOIN_SPEED	epuck.c	68;"	d	file:
MAX_SENS	epuck.c	40;"	d	file:
MAX_SPEED_BMR	epuck.c	69;"	d	file:
MIN_SENS	epuck.c	39;"	d	file:
MODE_ALL	epuck.c	85;"	d	file:
MODE_BRAI	epuck.c	81;"	d	file:
MODE_JOIN	epuck.c	84;"	d	file:
MODE_MIGR	epuck.c	83;"	d	file:
MODE_NO_SPEED	epuck.c	80;"	d	file:
MODE_PAUSE	epuck.c	79;"	d	file:
MODE_REYN	epuck.c	82;"	d	file:
M_PI	epuck.c	44;"	d	file:
NB_LEDS	epuck.c	38;"	d	file:
NB_SENSORS	epuck.c	37;"	d	file:
REYN_MIGR_RATIO	epuck.c	58;"	d	file:
RULE1_THRESHOLD	epuck.c	51;"	d	file:
RULE1_WEIGHT	epuck.c	53;"	d	file:
RULE2_THRESHOLD	epuck.c	52;"	d	file:
RULE2_WEIGHT	epuck.c	54;"	d	file:
RULE3_WEIGHT	epuck.c	55;"	d	file:
SATURATION_CHANGE	epuck.c	70;"	d	file:
SPEED_UNIT_RADS	epuck.c	47;"	d	file:
STOPPED_THRESHOLD	epuck.c	67;"	d	file:
TIME_READING	epuck.c	/^static const int TIME_READING = 800;$/;"	v	file:
TIME_RESET	epuck.c	/^static const int TIME_RESET = 100;$/;"	v	file:
TIME_SENDING	epuck.c	/^static const int TIME_SENDING = 800;$/;"	v	file:
TIME_STEP	epuck.c	/^static const int TIME_STEP = 10;$/;"	v	file:
WAIT_FOR_READING	epuck.c	64;"	d	file:
WAIT_FOR_SENDING	epuck.c	62;"	d	file:
WAIT_FOR_SENDING_RESET	epuck.c	63;"	d	file:
WHEEL_RADIUS	epuck.c	48;"	d	file:
_current_time	epuck.c	/^ void _current_time(void){$/;"	f
_reading_time	epuck.c	/^void _reading_time(void){$/;"	f
_reset_time	epuck.c	/^ void _reset_time(void){$/;"	f
_sending_time	epuck.c	/^void _sending_time(void){$/;"	f
bool	epuck.c	/^typedef enum { false = 0, true = !false } bool;$/;"	t	typeref:enum:__anon1	file:
buffer	epuck.c	/^static char buffer[80];$/;"	v	file:
check_if_reynolds	epuck.c	/^int check_if_reynolds(int msl, int msr, int alone) {$/;"	f
compute_wheel_speeds	epuck.c	/^void compute_wheel_speeds(int *msl, int *msr)$/;"	f
e_puck_matrix	epuck.c	/^static const int e_puck_matrix[16] =   {16,9,6,3, -1,-5,-6,-8,   -12,-8,-5,6, 2,4,5,9}; \/\/ for obstacle avoidance giving priority to a side$/;"	v	file:
epuck_receive_message	epuck.c	/^void epuck_receive_message(void){$/;"	f
epuck_send_message	epuck.c	/^void epuck_send_message(void)  $/;"	f
false	epuck.c	/^typedef enum { false = 0, true = !false } bool;$/;"	e	enum:__anon1	file:
flag_brai	epuck.c	/^static bool flag_brai = false;$/;"	v	file:
flag_join	epuck.c	/^static bool flag_join = false;$/;"	v	file:
flag_migr	epuck.c	/^static bool flag_migr = false;$/;"	v	file:
flag_reyn	epuck.c	/^static bool flag_reyn = false;$/;"	v	file:
flag_speed	epuck.c	/^static bool flag_speed = true;$/;"	v	file:
flag_time_reading	epuck.c	/^static bool flag_time_reading = true;$/;"	v	file:
flag_time_reset	epuck.c	/^static bool flag_time_reset = true;$/;"	v	file:
flag_time_sending	epuck.c	/^static bool flag_time_sending = true;$/;"	v	file:
flag_verbose	epuck.c	/^static bool flag_verbose = true;$/;"	v	file:
flag_verbose_speed	epuck.c	/^static bool flag_verbose_speed = false;$/;"	v	file:
flag_verbose_timer	epuck.c	/^static bool flag_verbose_timer = false;$/;"	v	file:
flockmates	epuck.c	/^static bool flockmates[FLOCK_SIZE] = {0};$/;"	v	file:
getselector	epuck.c	/^int getselector()$/;"	f
global2rel	epuck.c	/^void global2rel(float* v_global, float* v_ref){$/;"	f
join_speed	epuck.c	/^int join_speed = JOIN_SPEED;     \/\/ Speed added in join when join mode (retunrning to migr_diff = 0)$/;"	v
main	epuck.c	/^int main(){$/;"	f
max_speed_bmr	epuck.c	/^int max_speed_bmr = MAX_SPEED_BMR;      \/\/ Maximum speed$/;"	v
migr	epuck.c	/^static float migr[2] = {1.,0.};$/;"	v	file:
migr_diff	epuck.c	/^static float migr_diff = 0;$/;"	v	file:
migration_urge	epuck.c	/^void migration_urge(void) {$/;"	f
my_position	epuck.c	/^static float my_position[3];			 \/\/ X, Z, Theta of the current robot$/;"	v	file:
n_flockmates	epuck.c	/^int n_flockmates = 0;$/;"	v
no_reynolds	epuck.c	/^bool no_reynolds = 0;$/;"	v
normalize_speed	epuck.c	/^void normalize_speed(int *msl, int *msr, int max_speed) {$/;"	f
pow_id	epuck.c	/^int pow_id;$/;"	v
prev_global_pos	epuck.c	/^static float prev_global_pos[FLOCK_SIZE][2];    \/\/ Previous global  X, Z values$/;"	v	file:
prev_my_position	epuck.c	/^static float prev_my_position[3]; 		 \/\/ X, Z, Theta of the current robot in the previous time step$/;"	v	file:
prev_relative_pos	epuck.c	/^static float prev_relative_pos[FLOCK_SIZE][3];    \/\/ Previous relative  X, Z, Theta values$/;"	v	file:
rel2global	epuck.c	/^void rel2global(float* v_ref, float* v_global){$/;"	f
relative_pos	epuck.c	/^static float relative_pos[FLOCK_SIZE][3];    \/\/ relative X, Z, Theta of all robots$/;"	v	file:
relative_speed	epuck.c	/^static float relative_speed[FLOCK_SIZE][2];    \/\/ Speeds calculated with Reynold's rules$/;"	v	file:
reset	epuck.c	/^int reset()$/;"	f
reynolds_rules	epuck.c	/^void reynolds_rules() {$/;"	f
robot_group	epuck.c	/^static const int robot_group = 0;$/;"	v	file:
robot_id	epuck.c	/^static const int robot_id = 1;$/;"	v	file:
set_final_speed	epuck.c	/^float set_final_speed(int b_speed, int r_speed, int m_speed, int j_speed,int max_sens) {  \/\/weights for each of the speed (wb: Braitenberg, wm: Migration, wr: Reynolds)$/;"	f
set_mode	epuck.c	/^void set_mode(int mode){$/;"	f
speed	epuck.c	/^static float speed[FLOCK_SIZE][2];   	 \/\/ Speeds calculated with Reynold's rules$/;"	v	file:
time	epuck.c	/^static long int time = 0;					\/\/ Loop counter$/;"	v	file:
true	epuck.c	/^typedef enum { false = 0, true = !false } bool;$/;"	e	enum:__anon1	file:
update_self_motion	epuck.c	/^void update_self_motion(int msl, int msr) {$/;"	f
