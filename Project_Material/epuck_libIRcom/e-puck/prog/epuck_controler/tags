!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ABS	epuck.c	76;"	d	file:
AXLE_LENGTH	epuck.c	46;"	d	file:
BETA_MIGRATION	epuck.c	79;"	d	file:
BRAITENBERG_LOWER_THRESH	epuck.c	61;"	d	file:
BRAITENBERG_SPEED_BIAS	epuck.c	62;"	d	file:
BRAITENBERG_UPPER_THRESH	epuck.c	60;"	d	file:
DELTA_T	epuck.c	49;"	d	file:
FLOCK_SIZE	epuck.c	43;"	d	file:
INTIALISATION_STEPS	epuck.c	58;"	d	file:
MAX_SENS	epuck.c	41;"	d	file:
MAX_SPEED	epuck.c	42;"	d	file:
MIN_SENS	epuck.c	40;"	d	file:
MODE_ALL	epuck.c	70;"	d	file:
MODE_BRAI	epuck.c	67;"	d	file:
MODE_MIGR	epuck.c	69;"	d	file:
MODE_REYN	epuck.c	68;"	d	file:
M_PI	epuck.c	44;"	d	file:
NB_LEDS	epuck.c	39;"	d	file:
NB_SENSORS	epuck.c	38;"	d	file:
NO_SPEED	epuck.c	63;"	d	file:
REYN_MIGR_RATIO	epuck.c	59;"	d	file:
RULE1_THRESHOLD	epuck.c	51;"	d	file:
RULE1_WEIGHT	epuck.c	53;"	d	file:
RULE2_THRESHOLD	epuck.c	52;"	d	file:
RULE2_WEIGHT	epuck.c	54;"	d	file:
RULE3_WEIGHT	epuck.c	55;"	d	file:
SPEED_UNIT_RADS	epuck.c	47;"	d	file:
VERBOSE	epuck.c	73;"	d	file:
WAIT_FOR_SENDING	epuck.c	64;"	d	file:
WHEEL_RADIUS	epuck.c	48;"	d	file:
bool	epuck.c	/^typedef enum { false = 0, true = !false } bool;$/;"	t	typeref:enum:__anon1	file:
buffer	epuck.c	/^static char buffer[80];$/;"	v	file:
compute_wheel_speeds	epuck.c	/^void compute_wheel_speeds(int *msl, int *msr)$/;"	f
e_puck_matrix	epuck.c	/^static const int e_puck_matrix[16] =   {16,9,6,3, -1,-5,-6,-8,   -12,-8,-5,6, 2,4,5,9}; \/\/ for obstacle avoidance giving priority to a side$/;"	v	file:
epuck_receive_message	epuck.c	/^void epuck_receive_message(void){$/;"	f
epuck_send_message	epuck.c	/^void epuck_send_message(void)  $/;"	f
false	epuck.c	/^typedef enum { false = 0, true = !false } bool;$/;"	e	enum:__anon1	file:
flag_brai	epuck.c	/^static bool flag_brai = false;$/;"	v	file:
flag_migr	epuck.c	/^static bool flag_migr = false;$/;"	v	file:
flag_obstacle	epuck.c	/^static bool flag_obstacle = false;$/;"	v	file:
flag_reyn	epuck.c	/^static bool flag_reyn = false;$/;"	v	file:
flockmates	epuck.c	/^static bool flockmates[FLOCK_SIZE] = {0};$/;"	v	file:
getselector	epuck.c	/^int getselector()$/;"	f
global2rel	epuck.c	/^void global2rel(float* v_global, float* v_ref){$/;"	f
main	epuck.c	/^int main(){$/;"	f
migr	epuck.c	/^static float migr[2] = {1.,0.};$/;"	v	file:
migr_diff	epuck.c	/^static float migr_diff = 0;$/;"	v	file:
migration_urge	epuck.c	/^void migration_urge(void) {$/;"	f
my_position	epuck.c	/^static float my_position[3];			 \/\/ X, Z, Theta of the current robot$/;"	v	file:
normalize_speed	epuck.c	/^void normalize_speed(int *msl, int *msr) {$/;"	f
prev_global_pos	epuck.c	/^static float prev_global_pos[FLOCK_SIZE][2];    \/\/ Previous global  X, Z values$/;"	v	file:
prev_my_position	epuck.c	/^static float prev_my_position[3]; 		 \/\/ X, Z, Theta of the current robot in the previous time step$/;"	v	file:
prev_relative_pos	epuck.c	/^static float prev_relative_pos[FLOCK_SIZE][3];    \/\/ Previous relative  X, Z, Theta values$/;"	v	file:
rel2global	epuck.c	/^void rel2global(float* v_ref, float* v_global){$/;"	f
relative_pos	epuck.c	/^static float relative_pos[FLOCK_SIZE][3];    \/\/ relative X, Z, Theta of all robots$/;"	v	file:
relative_speed	epuck.c	/^static float relative_speed[FLOCK_SIZE][2];    \/\/ Speeds calculated with Reynold's rules$/;"	v	file:
reset	epuck.c	/^int reset()$/;"	f
reynolds_rules	epuck.c	/^void reynolds_rules() {$/;"	f
robot_group	epuck.c	/^static const int robot_group = 0;$/;"	v	file:
robot_id	epuck.c	/^static const int robot_id = 1;$/;"	v	file:
set_final_speed	epuck.c	/^float set_final_speed(int b_speed, int r_speed, int m_speed, int max_sens) {  \/\/weights for each of the speed (wb: Braitenberg, wm: Migration, wr: Reynolds)$/;"	f
set_mode	epuck.c	/^void set_mode(int mode){$/;"	f
speed	epuck.c	/^static float speed[FLOCK_SIZE][2];   	 \/\/ Speeds calculated with Reynold's rules$/;"	v	file:
true	epuck.c	/^typedef enum { false = 0, true = !false } bool;$/;"	e	enum:__anon1	file:
update_self_motion	epuck.c	/^void update_self_motion(int msl, int msr) {$/;"	f
